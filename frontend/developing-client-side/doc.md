Темы для разбора:
- Фазы распространения события (event propagation)
- new MouseEvent
- Конструкция `Array.from(nodeList).map()`
- FETCH API
- Делегирование событий (event delegation)
- Массивоподобные структуры в JS (HTMLCollection, Node, NodeList и т.д.)
- Web Storage API
- document.createDocumentFragment()
- Функции-аккумуляторы
- Как браузер отображает веб-страницу
- "flash of unstyled content" (FOUC)
- УЗЛЫ - что это такое? Node
- Строки DOMString
- Работа с JSON (json.stringify(), json.parse())
- Выписать все разрешения экранов для мобильной вёрстки
- Тестирование фронтенда (UI, вёрстка) - как проводить?
- Способы отправки данных на сервер (Fetch API, Navigator.sendBeacon, gtag.js, Image beacon, XMLHttpRequest)
- Практическое применение BOM элементов
- Отличие defer от вставки стилей в конце документа
- addEventListener - что это + аналоги
- События addEventListener
- UI
- Метрики UI
- Метрики для frontend-разработчика (как оценить эффективность приложения)
- Fullscreen API
- gtag (какой-то аналог fetch)
- XMLHttpRequest
- Canvas
- WebGL
- Phaser.js
- Стандартная библиотека JS (math, date и т.д.)
- Как работает курсор
- Как работает драг-н-дроп
- PWA (Progressive Web Apps)
- Управление сессиями
- Управление куками
- Short-circuit default (короткое замыкание к значению по умолчанию) - отсылает к механизму короткого замыкания оператора `||` в JS ( конструкция получить 'element' || '[]')

- ParentNode (+ Element, DocumentFragment)
- Перерисовка (reflow) и перекомпоновка (repaint) DOM-элементов при загрузке страницы.
- Локализация, Интернационализация
- i18next (библиотека для локализации)
- Функция-конструктор
- Core Web Vitals
- TypeScript
- jQuery
- tailwind
- Нормализация данных (1NF, 2NF и так далее);


## Что такое `document.documentElement`?
`document.documentElement` - это свойство объекта `document` (из DOM), которое возвращает корневой элемент HTML-документа. В большинстве случаев это элемент `<html>`. 
document.documentElement охватывает весь документ, включая `<head>` и `<body>`.

## Что такое `requestFullscreen()`?
`requestFullscreen()` - это метод Fullscreen API (часть BOM и HTML5), который переводит элемент (и его потомков) в полноэкранный режим. Браузер скрывает интерфейс (панели, адресную строку) и растягивает элемент на весь экран.
`exitFullscreen()` - выход из полноэкранного режима.

## Что такое `localStorage` и `sessionStorage`
Это интерфейсы веб-хранилища (Web Storage API) в браузерах, предоставляющие механизм хранения данных в формате "ключ-значение" на стороне клиента. Оба объекта:
- Являются свойствами глобального объекта `window` (можно обращаться как `localStorage` или `window.localStorage`, аналогично для `sessionStorage`).
- Работают с парами "ключ-значение", где и ключ, и значение - строки (даже если вы передаёте число или объект, они будут преобразованы в строку).

### Ключевые отличия
1. Срок хранения:
- `localStorage`: хранит данные бессрочно (пока пользователь не очистит кэш/хранилище вручную). Идеально для долгосрочных настроек (вроде темы для сайта)
- `sessionStorage`: данные живут только в течение сессии (удаляются при закрытии вкладки/окна браузера). Полезно для временных данных (например, форма заказа)

2. Область видимости:
- Оба хранилища изолированы по домену (например, `https://example.com` имеет своё `localStorage`, отличное от `https://another.com`).
- `sessionStorage` дополнительно изолирован по вкладке/окну (данные из одной вкладки не видны в другой).

### Основные методы (одинаковые для обоих)
- setItem(key, value) - сохраняет пару "ключ-значение";
- getItem(key) - получить значение по ключу.
- removeItem(key) - удалить пару по ключу.
- clear() - очистить всё хранилище.
- key(index) - получить ключ по индексу.
- length - количество элементов в хранилище.

### Важные нюансы
- Только строки. При сохранении объекта или числа, необходимо использовать `JSON.stringify()` при записи и `JSON.parse()` при чтении. Например:
```javascript
localStorage.setItem('user', JSON.stringify({ name: 'Alice' }));
const user = JSON.parse(localStorage.getItem('user'));
>>> user // { name: 'Alice' }
```
- Ограничение объёма: обычно около 5-10 МБ на домен (зависит от браузера).
- Не передаётся на сервер: данные не включаются в HTTP-запросы (в отличие от cookies)


## Что такое `JSON.stringify()` и `JSON.parse()`?
Это методы для преобразования JavaScript-объектов в строку JSON и обратно.
`JSON.stringify(value)`
- Преобразует значение (объект, массив, число, строку и т.д.) в строку формата JSON.
- Используется для сохранения сложных данных в `localStorage`, отправки данных на сервер и т.п.

`JSON.parse(string)`
- Преобразует строку JSON обратно в JavaScript-значение (объект, массив и т.д.).
- Используется для извлечения данных из `localStorage`, обработки ответов сервера и т.п.

Пример:
```javascript
const user = { name: 'Alice', age: 30 };
const jsonString = JSON.stringify(user); // '{'name': 'Alice', 'age': '30'}'
const jsonParse = JSON.parse(jsonString); // { name: 'Alice', age: 30 }
```

### Важные нюансы
- `localStorage` хранит только строки, поэтому для объектов/массивов обязательно нужно использовать `JSON.stringify()` при сохранении и `JSON.parse()` при чтении.
- Не все типы данных можно сериализовать (например, `Function`, `Date` без дополнительной обработки).


## Разница между методами `append` и `appendChild`
`append`
- Принимает набор узлов (Node) или строк (DOMString). Можно добавлять одновременно элементы, текст, фрагменты;
- Можно добавлять несколько элементов за один вызов (через запятую);
- Не возвращает ничего (undefined);
- Не поддерживается в Internet Explorer (требуется полифил)
- Вызывается у ParentNode (например, Element, DocumentFragment)

`appendChild`
- Принимает только один узел (Node). Строки не поддерживаются - нужно явно указать создавать текстовый узел через `document.createTextNode()`.
- Добавляет только один элемент за вызов. Для добавления нескольких нужно вызвать метод многократно.
- **Возвращает добавленный узел (Node), что позволяет использовать цепочку вызовов**
- Поддерживается во всех браузерах, включая старые версии IE.
- Вызывается у `Node`, включая элементы, текстовые узлы и др.


## Node, NodeList - разобрать

## Разница между подключением стилей в head, body и в отдельном документе
- `В <head>`: Рекомендуется. Стили загружаются до рендеринга тела, предотвращая "flash of unstyled content" (FOUC). Лучше для тела и доступности.
- `В <body>`: Стили загружаются позже, что может вызвать задержку отображения. Полезно для критических стилей ниже сгиба.
- `В отдельном файле`: Лучше для кэширования и разделения. Загружается асинхронно, но может блокировать рендеринг, если не использовать `media="print"` или preload.
Итог: В head быстрее начальный рендеринг + улучшает Core Web Vitals, отдельный файл - лучше для повторных загрузок (кеш) + упрощает управление. Body - медленнее, но позволяет рендерить контент раньше.

## insertAdjacentHTML, insertAdjacentElement
Оба метода позволяют вставлять контент в DOM-дерево относительно заданного элемента без полной перестройки его содержимого (в отличие от `innerHTML`).
- `insertAdjacentHtml(position, htmlString)` вставляет HTML-строку, которую бразуер барсит и преобразует в DOM-узлы.
- `insertAdjacentElement(position, element)` вставляет готовый DOM-элемент.
```javascript
const ul = document.getElementById('ul');
const li1 = document.createElement('li');

li1.textContent = 'Элемент 1';

const li2 = document.createElement('li');
li2.textContent = 'Элемент 2';

ul.appendChild(li1);
ul.appendChild(li2);

// Вставить после h1
const h1 = document.createElement('h1');
h1.textContent = 'Heading';

// ul.insertAdjacentElement('beforebegin', h1); // Вставка элемента перед ul (вне структуры ul)
// ul.insertAdjacentHTML('afterend', '<h1>dsfdsd</h1>'); // Вставка элемента после ul (вне структуры ul)

// ul.insertAdjacentElement('afterbegin', h1); // Вставка элемента в начало (внутри ul)
// ul.insertAdjacentElement('beforeend', h1); // Вставка элемента в конец (внутри ul)

console.log(ul.children)
```
