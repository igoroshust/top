## Понятие паттерна проектирования
Паттерн проектирования (design pattern) - это повторяющееся решение типичной проблемы, возникающей при разработке программного обеспечения. Это не готовый код, а шаблон или схема, описывающая принцип организации взаимодействия классов и объектов для достижения определённых целей, таких как гибкость, расширяемость или повторное использование кода. Паттерны не привязаны к конкретному ЯП, но чаще всего применяются в ООП.

### Паттерны классифицируются по назначению

- **Порождающие (creational)**: управляют процессом создания объектов (Singleton, Factory Method, Abstract Factory, etc).
- **Структурные (structural)**: описывают принцип составления объектов и классов в более крупные структуры (Adapter, Decorator, Composite).
- **Поведенческие (behavioral)**: определяют взаимодействие между объектами и распределение обязанностей (Observer, Strategy, Command).

Паттерны документируются с помощью описания: имя, проблема, решение, последствия (плюсы и минусы). Они помогают разработчикам не "изобретать велосипед" в попытках решить возникшую перед ними задачу, а следовать проверенным практикам.

### Singleton
`Singleton` гарантирует, что у класса есть только 1 экземпляр, и предоставляет глобальную точку доступа к нему. Это полезно для управления ресурсами, такими как подключение к БД, кэши, конфигурации (где можественные экземпляры нежелательны).

Пример в JS
```javascript
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance;
        }
        Singleton.instance = this;
        this.data = "Общий ресурс";
    }

    getData() {
        return this.data;
    }
}

const s1 = new Singleton();
const s2 = new Singleton();

console.log('s1 === s2 :>> ', s1 === s2); // true (один и тот же объект)
console.log('s1.getData() :>> ', s1.getData()); // Общий ресурс
```
Комментарии:
1. При каждом вызове `new Singleton()` конструктор проверяет, существует ли уже экземпляр класса.
2. `if (Singleton.instace)` - проверяет наличие уже сохранённого экземпляра в статическом свойстве Singleton.instance (оно привязано к классу, а не к экземпляру).
3. `Singleton.instance = this` - сохраняет текущий создаваемый объект (`this`) в статическое свойство класса. Это гарантирует, что следующий вызов конструктора найдёт существующий экземпляр.
4. `this.data = "Общий ресурс"` - инициализирует свойство экземпляра (выполняется только при первом создании).
5. `getData()` - метод получения данных экземпляра. Поскольку все вызовы `new Singleton` возвращают один и тот же объект, `this.data` всегда будет одинаковым.

В вышестоящем примере Singleton предотвращает создание множественных экземпляров, экономя память и обеспечивая согласованность данных. В JS это реализуется через статическое свойство класса.

### Observer
Observer позволяет объектам (наблюдателям) подписываться на изменения в другом объекте (субъекте) и автоматически реагировать. Используется в GUI-фреймворках для обновления интерфейса при изменении данных.
```javascript
class Subject {
    constructor() {
        this.observers = [];
    }

    addOberver(observer) {
        this.observers.push(observer);
        console.log('this.observers :>> ', this.observers);
        console.log('observer :>> ', observer);
    }

    notifyObservers(message) {
        this.observers.forEach(observer => observer.getInfo(message));
    }
}

class Observer {
    getInfo(message) {
        console.log(`Получено: ${message}`);
    }
}

// Использование
const subject = new Subject();
const observer = new Observer();
subject.addOberver(observer);
subject.notifyObservers("Изменение данных");
```
Комментарии:
1. `notifyObservers(message)` - метод для рассылки уведомлений. Проходит по всем наблюдателям и вызывает у каждого метод `getInfo()`.
2. `getInfo(message)` - метод, вызываемый субъектом при отправке уведомления. Выводит сообщение в консоль.

Паттерн Observer обеспечивает слабую связанность: субъект не знает деталей наблюдателей, что упрощает расширение системы. В JS это часто используется в реактивных библиотеках. таких как RxJS.


## Причины возникновения паттернов проектирования
ПП возникли в 1990х, когда разработчики ООП ПО столкнулись с повторяющимися проблемами. Книга "Design Patterns: Elements of Reusable Object-Oriented Software" (1994) Эриха Гаммы, Ричарда Хелма, Ральфа Джонсона, Джона Влиссидеса (банда четырёх) систематизировала их на основе опыта из Smalltalk и других проектов.

**Основные причины**
1. Повторяемость проблем. Схожие задачи вроде управления зависимостями, инкапсуляция поведения или обеспечение единственного экземпляра.
2. Необходимость стандартизации. Ранние ООП-системы (например, в C++ или Smalltalk) не имели встроенных механизмов для решения типичных задач. Паттерны предоставили общий язык и шаблоны, улучшая коммуникацию между разработчиками и снижая риск недопонимания.
3. Улучшение качества кода. Паттерны повышают читаемость, поддерживаемость и расширяемость. Они помогают избежать антипаттернов (плохих решений), таких как жёсткая связанность классов, которая усложняет тестирование и модификацию.
4. Эволюция технологий. С ростом сложности ПО (например, в GUI, сетевых приложениях) паттерны эволюционировали. Они адаптировались к новым парадигмам, таким как функциональное программирование, но изначально были ответом на вызовы ООП.
5. Экономические факторы. В коммерческой разработке паттерны сокращают время на разработку и отладку, позволяя переиспользовать решения. Без них проекты становились хрупкими при изменении требований.

Паттерны не догма - их применяют, когда они решают проблему лучше имеющихся альтернатив. Переиспользование паттернов без нужды может привести к over-engineering.

### Factory Method (причина возникновения)
Factory Method решает проблему создания объектов без указания конкретного класса, что полезно при работе с семействами связанных объектов (например, в кросс-платформенных приложениях). Factory Method помогает избежать "плодения" классов и модификации существующей логики при добавлении новых типов объектов. Вместо хардкодинга с вытекающими зависимостями при нововведениях, паттерн делегирует создание специальным методам или классам. Новые компоненты могут "цепляться" к этим фабричным методам, используя их для получения нужных объектов без знания деталей реализации. Это соответствует принципу открытости/закрытости: система открыта для расширения, но закрыта для модификации.

Проблема: клиент зависит от конкретных классов, что усложняет добавление новых ОС. 

С паттерном Factory Method
```javascript
class Button {
    render() {
        throw new Error("Метод render должен быть реализован");
    }
}

class WindowsButton extends Button {
    render() {
        console.log("Рендер Windows-кнопки");
    }
}

class ButtonFactory {
    static createButton(os) {
        if (os === "windows") {
            return new WindowsButton();
        }
        // Другие OS...
    }
}

// Клиентский код
const button = ButtonFactory.createButton("windows");
button.render();  // "Рендер Windows-кнопки"
```

Причина возникновения: в реальных проектах (например, GUI-фреймворках вроде Qt) добавление новых платформ требовало изменения клиентского кода. Паттерн абстрагирует создание, делая систему расширяемой без модификации существующих классов. Это снизило ошибки и улучшило поддерживаемость, что было ключом в эпоху становления ООП.В JS этот паттерн часто применяется в модульных системах для создания компонентов без жёсткой зависимости.


## Принципы применения паттернов проектирования
ПП - это проверенные решения типичных проблем в ООП-программировании. Они помогают создавать гибкий, поддерживаемый и расширяемый код. Основные принципы применения основаны на принципах SOLID (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) и избегают переусложнения. Ключевые принципы:
- Применение паттернов при необходимости. Они должны решать реальную проблему, такую как высокая связанность (coupling) или низкая гибкость. Если простое решение работает, выбираем его.
- Следуйте принципу единой ответственности. Каждый паттерн должен фокусироваться на одной задаче. Например, паттерн Observer разделяет логику уведомлений от основной бизнес-логики.
- Обеспечивайте открытость для расшенеия и закрытость для модификации. Паттерны вроде Strategy или Factory позволяют добавлять новые поведения без изменения существующего кода.
- Избегание антипаттернов. Не применять паттерны, если они усложняют код (например, Singleton может создать глобальное состояние, приводящее к проблемам тестирования).
- Тестирование и рефакторинг. После применения паттерна нужно проверить, улучшает ли он читаемость и производительность.

**Практический пример. Реализация паттерна Strategy для расчёта скидок в интернет-магазине**
```javascript
class DiscountStrategy {
    apply(total) {
        throw new Error("Метод apply должен быть реализован");
    }
}

class FixedDiscount extends DiscountStrategy {
    apply(total) {
        return total - 10;
    }
}

class PercentageDiscount extends DiscountStrategy {
    apply(total) {
        return total * 0.9;
    }
}

class Order {
    constructor(total, strategy) {
        this.total = total;
        this.strategy = strategy;
    }

    getFinalPrice() {
        return this.strategy.apply(this.total);
    }
}

// Использование
const order = new Order(100, new PercentageDiscount());
console.log(order.getFinalPrice());
```
Это позволяет добавлять новые стратегии без изменения Order, следуя принципу открытости/закрытости.

**`Strategy`**
Strategy - поведенческий паттерн проектирования, позволяющий динамически выбирать и заменять алгоритмы внутри объекта без изменения его интерфейса. Суть: вместо жёсткой привязки к одному алгоритму, объект-контекст:
- работает с абстрактным интерфейсом стратегии;
- делегирует выполнение алгоритма конкретному объекту-стратегии;
- может менять стратегию в любой момент (даже во время выполнения программы).

## Принципы выбора паттернов проектирования
Выбор паттерна зависит от конкретной проблемы, контекста и требований (гибкость, производительность, простота). Основные принципы:
- Анализируйте проблему: определить, является ли он связанной с созданием объектов (creational), структурой классов (structural) или поведением (behavioral). Используйте диаграммы UML или описания проблем для сопоставления.

- Учитывайте принципы SOLID и DRY: выбирайте паттерн, который минимизирует дублирование и повышает модульность. Например, если код повторяется в разных классах, подумайте о Template Method.

- Оценивайте компромиссы. Паттерны могут влиять на производительность (например, Observer добавляет дополнительные расходы на уведомления) или сложность. Для простых задач предпочтительны простые решения.

- Контекст приложения: в веб-разработке часто используется MVC (Model-View-Controller, хотя это не GoF-паттерн), в многопоточных системах - Singleton или Producer-Consumer.

- Итеративный подход: начинаем с простого решения, затем рефакторим к паттерну, если проблема растёт. Используйте инструменты вроде Refactoring Guru или Head First Design Patterns для выбора.

**Практический пример: выбор паттерна для обработки заказов в ресторане**
Проблема: разные типы заказов (еда, напитки) требуют разных обработчиков, но логика должна быть гибкой. Если фокус на создании объектов (например, разные типы заказов) - выбирайте Factory Method. Если на структуре (композиция объектов) - Decorator для добавления опций (например, добавка сыра). Если на поведении (последовательность действий) - Chain of Responsibility для обработки заказов разными сотрудниками.

Пример с Factory Method
```javascript
class Order {
  prepare() {
    throw new Error("Метод prepare() не реализован.");
  }
}

class DrinkOrder extends Order {
  prepare() {
    console.log("Preparing drink");
  }
}

class FoodOrder extends Order {
  prepare() {
    console.log("Preparing food");
  }
}

class OrderFactory {
  static createOrder(type) {
    switch (type) {
      case "drink":
        return new DrinkOrder();
      case "food":
        return new FoodOrder();
      default:
        throw new Error("Unknown type");
    }
  }
}

const order = OrderFactory.createOrder("food");
order.prepare();
```

## Принципы разделения паттернов на категории
Паттерны проектирования из книги "Gang of Four" (GoF) делятся на три категории на основе решаемых задач: creational (создание объектов), structural (структура классов/объектов) и behavioral (поведение объектов). Принципы разделения:
- **Creational**: фокусируются на гибком создании объектов, избегая жёсткой зависимости от конкретных классов. Примеры: Singleton, Factory Method, Abstract Factory, Builder, Prototype.
- **Structural**: организуют отношения между классами/объектами для формирования больших структур. Примеры: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.
- **Behavioral**: определяют взаимодействие объектов и распределение ответственности. Примеры: Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor.

Принципы разделения: категории оснваны на цели паттерна (что он решает), а не на реализации. Это помогает разработчикам быстро находить паттерн по типу проблемы. Категории не строгие - некоторые паттерны могут пересекаться (например, Strategy - behavioral, но может использоваться в creational контексте).

**Пример с Composite**
```javascript
class Task {
  execute() {
    throw new Error("Метод execute должен быть реализован");
  }
}

class SimpleTask extends Task {
  execute() {
    console.log("Executing simple task");
  }
}

class Project extends Task {
  constructor() {
    super();
    this.tasks = [];
  }

  add(task) {
    this.tasks.push(task);
  }

  execute() {
    this.tasks.forEach((task) => task.execute());
  }
}

// Использование
const project = new Project();
project.add(new SimpleTask());
project.add(new SimpleTask());
project.execute();
```
Это демонстрирует структурный паттерн для композиции объектов, позволяя обрабатывать группы как единое целое.

**`Composite`**
Composite - структурный паттерн проектирования, позволяющий объединять объекты в древовидные структуры (части-целое) и работать с ними как с единичным объектом. Паттерн решает проблему единообразного обращения к:
- простым (листовым) объектам (части);
- составным объектам (целое, содержащее другие объекты);

Благодаря общему интерфейсу клиентский код не различает, с чем работает - с одиночным элементом или группой.