## Понятие паттерна проектирования
Паттерн проектирования (design pattern) - это повторяющееся решение типичной проблемы, возникающей при разработке программного обеспечения. Это не готовый код, а шаблон или схема, описывающая принцип организации взаимодействия классов и объектов для достижения определённых целей, таких как гибкость, расширяемость или повторное использование кода. Паттерны не привязаны к конкретному ЯП, но чаще всего применяются в ООП.

### Паттерны классифицируются по назначению

- **Порождающие (creational)**: управляют процессом создания объектов (Singleton, Factory Method, Abstract Factory, etc).
- **Структурные (structural)**: описывают принцип составления объектов и классов в более крупные структуры (Adapter, Decorator, Composite).
- **Поведенческие (behavioral)**: определяют взаимодействие между объектами и распределение обязанностей (Observer, Strategy, Command).

Паттерны документируются с помощью описания: имя, проблема, решение, последствия (плюсы и минусы). Они помогают разработчикам не "изобретать велосипед" в попытках решить возникшую перед ними задачу, а следовать проверенным практикам.

### Singleton
`Singleton` гарантирует, что у класса есть только 1 экземпляр, и предоставляет глобальную точку доступа к нему. Это полезно для управления ресурсами, такими как подключение к БД, кэши, конфигурации (где можественные экземпляры нежелательны).

Пример в JS
```javascript
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance;
        }
        Singleton.instance = this;
        this.data = "Общий ресурс";
    }

    getData() {
        return this.data;
    }
}

const s1 = new Singleton();
const s2 = new Singleton();

console.log('s1 === s2 :>> ', s1 === s2); // true (один и тот же объект)
console.log('s1.getData() :>> ', s1.getData()); // Общий ресурс
```
Комментарии:
1. При каждом вызове `new Singleton()` конструктор проверяет, существует ли уже экземпляр класса.
2. `if (Singleton.instace)` - проверяет наличие уже сохранённого экземпляра в статическом свойстве Singleton.instance (оно привязано к классу, а не к экземпляру).
3. `Singleton.instance = this` - сохраняет текущий создаваемый объект (`this`) в статическое свойство класса. Это гарантирует, что следующий вызов конструктора найдёт существующий экземпляр.
4. `this.data = "Общий ресурс"` - инициализирует свойство экземпляра (выполняется только при первом создании).
5. `getData()` - метод получения данных экземпляра. Поскольку все вызовы `new Singleton` возвращают один и тот же объект, `this.data` всегда будет одинаковым.

В вышестоящем примере Singleton предотвращает создание множественных экземпляров, экономя память и обеспечивая согласованность данных. В JS это реализуется через статическое свойство класса.

### Observer
Observer позволяет объектам (наблюдателям) подписываться на изменения в другом объекте (субъекте) и автоматически реагировать. Используется в GUI-фреймворках для обновления интерфейса при изменении данных.
```javascript
class Subject {
    constructor() {
        this.observers = [];
    }

    addOberver(observer) {
        this.observers.push(observer);
        console.log('this.observers :>> ', this.observers);
        console.log('observer :>> ', observer);
    }

    notifyObservers(message) {
        this.observers.forEach(observer => observer.getInfo(message));
    }
}

class Observer {
    getInfo(message) {
        console.log(`Получено: ${message}`);
    }
}

// Использование
const subject = new Subject();
const observer = new Observer();
subject.addOberver(observer);
subject.notifyObservers("Изменение данных");
```
Комментарии:
1. `notifyObservers(message)` - метод для рассылки уведомлений. Проходит по всем наблюдателям и вызывает у каждого метод `getInfo()`.
2. `getInfo(message)` - метод, вызываемый субъектом при отправке уведомления. Выводит сообщение в консоль.

Паттерн Observer обеспечивает слабую связанность: субъект не знает деталей наблюдателей, что упрощает расширение системы. В JS это часто используется в реактивных библиотеках. таких как RxJS.


## Причины возникновения паттернов проектирования
ПП возникли в 1990х, когда разработчики ООП ПО столкнулись с повторяющимися проблемами. Книга "Design Patterns: Elements of Reusable Object-Oriented Software" (1994) Эриха Гаммы, Ричарда Хелма, Ральфа Джонсона, Джона Влиссидеса (банда четырёх) систематизировала их на основе опыта из Smalltalk и других проектов.

**Основные причины**
1. Повторяемость проблем. Схожие задачи вроде управления зависимостями, инкапсуляция поведения или обеспечение единственного экземпляра.
2. Необходимость стандартизации. Ранние ООП-системы (например, в C++ или Smalltalk) не имели встроенных механизмов для решения типичных задач. Паттерны предоставили общий язык и шаблоны, улучшая коммуникацию между разработчиками и снижая риск недопонимания.
3. Улучшение качества кода. Паттерны повышают читаемость, поддерживаемость и расширяемость. Они помогают избежать антипаттернов (плохих решений), таких как жёсткая связанность классов, которая усложняет тестирование и модификацию.
4. Эволюция технологий. С ростом сложности ПО (например, в GUI, сетевых приложениях) паттерны эволюционировали. Они адаптировались к новым парадигмам, таким как функциональное программирование, но изначально были ответом на вызовы ООП.
5. Экономические факторы. В коммерческой разработке паттерны сокращают время на разработку и отладку, позволяя переиспользовать решения. Без них проекты становились хрупкими при изменении требований.

Паттерны не догма - их применяют, когда они решают проблему лучше имеющихся альтернатив. Переиспользование паттернов без нужды может привести к over-engineering.

### Factory Method (причина возникновения)
Factory Method решает проблему создания объектов без указания конкретного класса, что полезно при работе с семействами связанных объектов (например, в кросс-платформенных приложениях). Factory Method помогает избежать "плодения" классов и модификации существующей логики при добавлении новых типов объектов. Вместо хардкодинга с вытекающими зависимостями при нововведениях, паттерн делегирует создание специальным методам или классам. Новые компоненты могут "цепляться" к этим фабричным методам, используя их для получения нужных объектов без знания деталей реализации. Это соответствует принципу открытости/закрытости: система открыта для расширения, но закрыта для модификации.

Проблема: клиент зависит от конкретных классов, что усложняет добавление новых ОС. 

С паттерном Factory Method
```javascript
class Button {
    render() {
        throw new Error("Метод render должен быть реализован");
    }
}

class WindowsButton extends Button {
    render() {
        console.log("Рендер Windows-кнопки");
    }
}

class ButtonFactory {
    static createButton(os) {
        if (os === "windows") {
            return new WindowsButton();
        }
        // Другие OS...
    }
}

// Клиентский код
const button = ButtonFactory.createButton("windows");
button.render();  // "Рендер Windows-кнопки"
```

Причина возникновения: в реальных проектах (например, GUI-фреймворках вроде Qt) добавление новых платформ требовало изменения клиентского кода. Паттерн абстрагирует создание, делая систему расширяемой без модификации существующих классов. Это снизило ошибки и улучшило поддерживаемость, что было ключом в эпоху становления ООП.В JS этот паттерн часто применяется в модульных системах для создания компонентов без жёсткой зависимости.

