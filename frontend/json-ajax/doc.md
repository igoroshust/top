- Стандарт RFC 8259
- RESTful API

https://app.blackbox.ai/chat/k1MBf8b

## Цели и задачи JSON в JavaScript
JSON (JavaScript Object Notation) - это текстовый формат для представления структурированных данных, основанный на синтаксисе JS. Он был разработан для облегчения обмена данными между различными системами, особенно в веб-разработке, где данные часто передаются между клиентом (браузером) и сервером. 

### Основные цели JSON
- **Универсальность и совместимость**. JSON поддерживается большинством ЯП, что делает его идеальным для межплатформенного обмена данными. Он не зависит от JS, хотя и используется его синтаксис.

- **Легковесность и читаемость**. Формат компактный, легко читается человеком и парсируемый машинами. Это упрощает отладку и разработку.

- **Стандартизация**. JSON является стандартом (RFC 8259), что обеспечивает надёжность и предсказуемость.

### Задачи JSON в JS
- **Сериализация (преобразование объектов в строку)**. Преобразование JS-объектов в JSON-строку для передачи или хранения с помощью `JSON.stringify()`

- **Десериализация (преобразование строки обратно в объект)**. Парсинг JSON-строки в JS-объект с помощью `JSON.parse()`

- **Хранение и передача данных**. Используется для сохранения данных в localStorage/sessionStorage, отправки AJAX-запросов, работы с API (например, RESTful API).

JSON решает проблемы, связанные с передачей сложных структур данных (объекты, массивы) через текстовые протоколы, такие как HTTP, где данные должны быть строковыми.

### Примеры

**Пример-1. Передача объекта с данными пользователя на сервер**
```javascript
const user = {
    name: "Иван",
    age: 30,
    hobbies: ["чтение", "спорт"]
};

// Сериализация в JSON-строку
const jsonString = JSON.stringify(user);
console.log(jsonString); // Вывод: {"name": "Иван", "age": 30, "hobbies": ["чтение", "спорт"]}
console.log(typeof jsonString); // string

// Имитация отправки на сервер
fetch('/api/user', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: jsonString
});

// Десериализация обратно в объект
const parsedUser = JSON.parse(jsonString); // {name: "Иван", ...}
console.log(parsedUser.name);
```
В этом примере JSON позволяет легко преобразовать объект в строку для передачи и обратно, сохраняя структуру данных.


### Синтаксис JSON
Синтаксис JSON строго определён и основан на подмножестве JavaScript. Он поддерживает только определённые типы данных и структуры, без функций, комментариев или переменных.

#### Основные элементы синтаксиса
- **Объекты**: Представляются в фигурных скобках, содержат пары "ключ:значение", где ключи - строки в двойных кавычках, значения - допустимые типы данных.
- **Массивы**: Представляются в квадратных скобках, содержат упорядоченные значения.
- **Типы данных**: Cтроки, числа, булевы значения, null, объекты и массивы (могут быть вложенными)
- **Правила**: 
- - Ключи объектов всегда в двойных кавычках;
- - Нет комментариев, функций, undefined и символов;
- - Запятые обязательны между элементами, но не после последнего;
- - Пробелы и отступы игнорируются (для читаемости).

JSON не является полноценным JavaScript: он не поддерживает выражения, переменные или методы. Если попытаться сериализовать объект с функцией, она будет пропущена.

**Пример-1. Валидный JSON с вложенными структурами**
```javascript
const jsonData = `{
    "user": {
        "name": "Анна",
        "age": 25,
        "isActive": true,
        "address": {
            "city": "Москва",
            "zip": 123456
        },
        "friends": ["Пётр", "Мария", null]
    },
    "metadata": {
        "version": 1.0,
        "created": "2023-10-01"
    }
}`;

// Парсинг в JSON-объект
const data = JSON.parse(jsonData);
console.log(data); // { user: {...}, metadata: {...} }
console.log(data.user.name); // Анна
console.log(data.user.friends[1]); // Мария

// Сериализация обратно
const backToJson = JSON.stringify(data, null, 2); // С отступами для читаемости

console.log(backToJson); 
/* {
  "user": {
    "name": "Анна",
    "age": 25,
    "isActive": true,
    "address": {
      "city": "Москва",
      "zip": 123456
    },
    "friends": [
      "Пётр",
      "Мария",
      null
    ]
  },
  "metadata": {
    "version": 1,
    "created": "2023-10-01"
  }
*/
```

**Пример-2. Пропуск недопустимого элемента (например, функции)**
```javascript
const obj = { name: "Тест", func: function () { return 1; } };
console.log(JSON.stringify(obj)); // { "name": "Тест" }
```

### Работа JSON.stringify()
JSON.stringify() преобразует JS-значение (объект, массив, число, строку, булево значение, null) в строку в формате JSON.
Пример
```javascript
const obj = { name: "Алиса", age: 25, isActive: true };
const jsonString = JSON.stringify(obj);
// Результат: '{"name":"Алиса", ...}'
```

**Важные нюансы**
- Не обрабатывает функции, undefined, Symbol (они пропускаются или превращаются в null)
- Для Date вызывает .toJSON() (результат - строка в формате ISO)
- Циклические ссылки вызовут ошибку
- Можно настроить через параметры (например, отступы для читаемости)

#### Параметры JSON.stringify(value, replacer, space)
1. `value` (обязательный). Исходное значение (объект, массив, примитив), которое нужно преобразовать в JSON-строку.
2. `replacer` (опциональный). Может быть:
- - функцией, вызываемой для каждого свойства, позволяющей модифицировать значение перед записью.
```javascript
// Абстрактно
JSON.stringify({a: 1, b: 2}, (key, value) => value * 2); // {"a": 2, "b": 4}

// Расширенный пример кода
const result = JSON.stringify(
  {a: 1, b: 2},
  (key, value) => {
    // Для корневого объекта возвращаем его как есть
    if (key === '') return value;
    // Для числовых значений умножаем на 2
    if (typeof value === 'number') return value * 2;
    // Для остальных типов (строки, объекты и т. п.) оставляем без изменений
    return value;
  }
);
console.log(result); // '{"a":2,"b":4}'
```
- - массивом строк/чисел, указывающим, какие свойства включать в результат (фильтрация по ключам).
```javascript
JSON.stringify({a: 1, b: 2, c: 3, d: 4}, ['a', 'd']);
// {"a": 1, "d": 4}
```
3. `space` (опциональный). Управляет форматированием отступов для читаемости. Может быть:
- - числом (от 0 до 10): количество пробелом для отступа
Пример со space=2
```json
{
  "name": "Алиса",
  "age": 25
}
```

- - строкой (до 10 символов): используется как символ отступа
Пример со space='\t'
```json
{
    "name": "Алиса",
    "age": 25
}
```

#### Параметры JSON.stringify(value, replacer, space)
1. `value` (обязательный). Исходное значение (объект, массив, примитив), которое нужно преобразовать в JSON-строку.
2. `replacer` (опциональный). Может быть:
- - функцией, вызываемой для каждого свойства, позволяющей модифицировать значение перед записью.
```javascript
// Абстрактно
JSON.stringify({a: 1, b: 2}, (key, value) => value * 2); // {"a": 2, "b": 4}

// Расширенный пример кода
const result = JSON.stringify(
  {a: 1, b: 2},
  (key, value) => {
    // Для корневого объекта возвращаем его как есть
    if (key === '') return value;
    // Для числовых значений умножаем на 2
    if (typeof value === 'number') return value * 2;
    // Для остальных типов (строки, объекты и т. п.) оставляем без изменений
    return value;
  }
);
console.log(result); // '{"a":2,"b":4}'
```
- - массивом строк/чисел, указывающим, какие свойства включать в результат (фильтрация по ключам).
```javascript
JSON.stringify({a: 1, b: 2, c: 3, d: 4}, ['a', 'd']);
// {"a": 1, "d": 4}
```
3. `space` (опциональный). Управляет форматированием отступов для читаемости. Может быть:
- - числом (от 0 до 10): количество пробелом для отступа
Пример со space=2
```json
{
  "name": "Алиса",
  "age": 25
}
```

- - строкой (до 10 символов): используется как символ отступа
Пример со space='\t'
```json
{
    "name": "Алиса",
    "age": 25
}
```

**Пример-1: исключение определённых свойств с помощью replacer-функции**
```javascript
const user = {
  name: 'Олег',
  password: "secret123", // Не хотим сериализовать
  age: 28,
  email: "oleg@example.com"
};

// Replacer-функция: исключаем password
const jsonString = JSON.stringify(user, (key, value) => {
  if (key === 'password') return undefined; // Исключаем
  return value;
});

console.log(jsonString); // Вывод: {"name":"Олег","age":28,"email":"oleg@example.com"}
```

**Пример-2: включаем только определённые ключи**
```javascript
const user = {
  name: 'Олег',
  password: "secret123", // Не хотим сериализовать
  age: 28,
  email: "oleg@example.com"
};

// Replacer-функция: только name и age
const jsonString = JSON.stringify(user, ['name', 'age']);
console.log(jsonString); // Вывод: {"name":"Олег","age":28}
```

**Пример-3: трансформация возраста в строку + отступы**
```javascript
const user = {
  name: 'Олег',
  age: 28
};

const jsonString = JSON.stringify(user, (key, value) => {
  if (key === 'age') return value.toString();
  return value;
}, 2);

console.log(jsonString);
```


#### Параметры JSON.parse(text, reviver)
1. `text` (обязательный). Строка в формате JSON, которую нужно преобразовать в JS-значение.
2. `replacer` (опциональный). Функция, которая вызывается для каждого парсируемого значения. Позволяет:
- - модифицировать значения перед их возвратом;
- - фильтровать или удалять свойства;
- - преобразовывать типы данных;

Пример преобразования строк с датами в объекты Date
```javascript
const str = '{"date": "2025-01-01", "value": 100}';

const obj = JSON.parse(str, (key, value) => {
  if (key === 'date') return new Date(value);
  return value;
});

console.log(obj); // {date: Wed Jan 01 2025 09:00:00 GMT+0900 (Якутск, стандартное время), value: 100}
```

**Важные нюансы**
- Строка должна строго соответствовать синтаксису JSON (двойные кавычки, без запятых после последнего элемента и тп);
- При ошибке выбрасывает SyntaxError.


#### Итоговый обзор
1. JSON.stringify(value, replacer, space) - преобразует JS-значение в JSON-строку с возможностью фильтрации и форматирования
2. JSON.parse(text, reviver) - преобразует JSON-строку в JS-значение с возможностью постобработки


### Метод toJSON()
Метод `toJSON()` - это специальный метод, который можно добавить к объекту для кастомизации его сериализации. Когда `JSON.stringify()` встречает объект с этим методом, он автоматически вызывает `toJSON()` и использует его возвращаемое значение вместо самого объекта.

**Использование**
- Для встроенных объектов, таких как `Date` (уже имеет toJSON, возвращает ISO-строку).
- Для кастомных классов или объектов, где нужно контролировать, как они сериализуются (например, исключить внутренние свойства или преобразовать данные).
- Метод вызывается только при сериализации, не влияет на десериализацию.

**Практический пример: кастомный объект с toJSON для упрощения вывода**
```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
    this.secret = "не сериализовать"; // Внутреннее свойство
  }

  toJSON() {
    return {
      name: this.name,
      age: this.age
    }; // Возвращаем только нужные поля
  }
}

const person = new Person("Елена", 35);
const jsonString = JSON.stringify(person);
console.log(jsonString); // {"name":"Елена","age":35}
```

**Практический пример с Date: встроенный toJSON**
```javascript
const now = new Date();
console.log(JSON.stringify(now)); // Вывод: "2023-10-01T12:00:00.000Z" (ISO-строка)
```


**Пример комбинации с replacer**
```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
    this.secret = "не сериализовать"; // Внутреннее свойство
  }

  toJSON() {
    return {
      name: this.name,
      age: this.age
    }; // Возвращаем только нужные поля
  }
}

const person = new Person("Максим", 40);
const jsonString = JSON.stringify(person, (key, value) => {
  if (key === 'age') return value + 1; // Увеличиваем возраст
  return value;
});

console.log(jsonString); // Вывод: {"name":"Максим","age":41}
```
Это позволяет гибко управлять сериализацией, делая JSON более мощным инструментом в JavaScript.


### Дополниельно по теме
1. `Сериализация` - это процесс преобразования объекта или структуры данных в формат, подходящий для хранения, передачи или восстановления, обычно в строку или поток байтов. В контексте JS это часто относится к преобразованию JS-объектов в JSON-строку с помощью `JSON.stringify()`.
- Цель: позволяет сохранить состояние объектов (например, в файлы, базы данных или передавать по сети), чтобы позже восстановить их.
```javascript
// Сериализация объекта
JSON.stringify({ name: "Иван", "age": 30 }); // :>> '{"name": "Иван", "age": "30"}'

// Десериализация (восстановление)
JSON.parse('{"name": "Иван", "age": "30"}'); // :>> объект { name: "Иван", "age": 30 }
```
Применение: используется в веб-разработке для отправки данных на сервер, кэширования или хранения в localStorage.

2. `Сериализатор` - это инструмент, функция или класс, который выполняет сериализацию. В JS встроенный сериализатор - это метод `JSON.stringify()`, который преобразует объекты в JSON-строки.
- Функциональность: принимает объект и опционально параметры (replacer, space) для кастомизации вывода.
- Примеры:
- - Простой сериализатор: `JSON.stringify(obj)`
- - С кастомизацией: `JSON.stringify(obj, ['name', 'age'], 2)` - включает только указанные ключи с отступами
- Расширения: можно создать собственный сериализатор, например, для XML или бинарных форматов, но в JS JSON - стандарт.

3. Этимология термина "сериализация"
Происходит от латинского "series" (ряд, последовательность), что подразумевает преобразование данных в последовательную формы (например, строку или поток). Термин появился в программировании в 1960-х годах, связанный с сериализацией объектов в языках вроде Smalltalk и Java.
- Происхождение: от 'serial" (последовательный) + суффикс 'ization' (процесс). Аналогично русскому "серия", "последовательность".
- В программировании - отражает идею "выстраивания" данных в линейную последовательность для хранения или передачи.
- Примеры использования: В контексте JSON - данные "выстраиваются" в текстовую строку.

4. ISO-строка
ISO-строка - это строковое представление даты и времени в формате ISO 8601, стандартизированном Международной организацией по стандартизации (ISO). В JS это формат, возвращаемый методом `Date.prototype.toISOString()`, например, `2023-10-01T12:00:00.000Z`.
- Формат: YYYY-MM-DDTHH:mm:ss.sssZ (год-месяц-деньТчасы:минуты:секунды.милисекундыZ - для UTC)
- В JSON: объекты Date автоматически сериализуются в ISO-строки с помощью `toJSON()`.
- Примеры:
- - `new Date().toISOString()` :>> `"2023-10-01T12:00:00.000Z"`
- - В JSON: `JSON.stringify(new Date())` :>> `"2023-10-01T12:00:00.000Z"`

5. Стандарт RFC 8259
RFC 8259 - это документ, опубликованный Internet Engineering Task Force (IETF), который определяет стандарт JSON  (JavaScript Object Notation). Он заменил более ранние спецификации (RFC 4627) и уточняет синтаксис, типы данных и безопасность.
- Ключевые аспекты: описывает JSON как текстовый формат для обмена данными, поддерживающий объекты, массивы, строки, числа, булевы значения и null. Устанавливает правила парсинга и сериализации.
- Применение: Используется в веб-API, конфигурационных файлах и базах данных. В JS реализация соответствует этому стандарту.
- Примеры: Любая JSON-строка должна следовать правилам RFC 8259, например, ключи в двойных кавычках, отсутствие комментариев.

6. RESTful API
RESTFul API - архитектурный стиль для создания веб-сервисов, основынный на принципах REST (Representational State Transfer), предложенных Роем Филдингом. Он использует HTTP-методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами, представленными в виде URL.
- Принципы: клиент-серверная модель, без состояния (stateless), кэшируемость, унифицированный интерфейс. Данные обычно передаются в JSON.
- Применение: широко используются для веб-приложений, мобильных API и микросервисов. Примеры: GitHub API, Twitter API.
- Примеры:
- - `GET /users` - получить список пользователей (возвращает JSON)
- - `POST /users` - создать нового пользователя (отправляет JSON-данные)
- - В JS: `fetch('/api/users', { method: 'GET' }).then(res => res.json())` - получение данных в JSON-формате.

