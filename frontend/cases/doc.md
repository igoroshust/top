- spread operator
- rest opertator
- Array.from()
- for...of
- regex
- ES6+
- iterator + generator

- arguments
- reduce
- map
- filter
- findIndex
- for in
- new Set
- arguments
- nodelist
- массивоподобные объекты

## Цикл for...of
`for...of` - современный (ES6+) способ перебора значений итерируемых объектов в JS. Лаконичный, читаемый, работающий со многими типами данных.

Синтаксис
```javascript
for (const элемент of итерируемый объект) {
    // действия с элементом
}
```
- Элемент: переменная, которая на каждой итерации получает очередное значение из коллекции;
- Итерируемый объект: массив, строка, Set, Map, NodeList и др.

Пример работы
```javascript
const fruits = ['яблоко', 'банан', 'вишня'];
for (const fruit of fruits) {
    console.log(fruit);
}
// Вывод: яблоко, банан, вишня
```

**Как работает**
1. Цикл запрашивает у объекта итератор (метод `Symbol.iterator`);
2. Последовательно вызывает метод `next()` итератора, получая объекты вида `{ value: ..., done: ... }`;
3. Пока `done` не станет `true`, присваивает `value` переменной `элемент` и выполняет тело цикла;
4. Когда итерация завершена, цикл заканчивается.

**Для каких объектов подходит**
- Массивы: `['a', 'b', 'c']`
- Строки: `'hello'`
- Set: `new Set([1, 2, 3])`
- Map: `new Map([['a', 1], ['b', 2]])`
- DOM-коллекции: `document.querySelectorAll('p')` (NodeList)
- Типизированные массивы: `Uint8Array`
- Генераторы: функции с `function*` и `yield`


## Итератор + генератор
Итератор - объект, который позволяет последовательно получать элементы коллекции по одному.
Генератор - особый вид итератора, создаваемый через `function*` и `yield` (в JS).

### Итераторы
Итераторы нужны для низкоуровневого контроля над процессом итерации (например, для кастомных структур данных).

- Реализуются через метод `Symbol.iterator`.
- Возвращает объект с методом `next()`, который выдаёт:
- - `{ value: <текущее значение>, done: false }` - пока есть элементы;
- - `{ value: undefined, done: true }` - когда итерация завершена;

Примеры итерируемых объектов: Array, String, Map, Set, NodeList

**Пример ручного итератора**
```javascript
const iterable = [1, 2, 3];
const iterator = iterable[Symbol.iterator]();

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

### Генератор
Генераторы нужны, когда требуется лениво генерировать значения (экономия памяти), реализовывать бесконечные последовательности, упростить код за счёт yield.
Генератор - это итератор, элементы которого можно проитерировать 1 раз.
Генератор - это удобный способ создавать итераторы.


- Создаются с помощью `function*`
- Используют `yield` для "паузы" и возврата значения.
- Автоматически реализуют протокол итератора.

При вызове функция-генератор не выполняется немедленно, а возвращает объект-генератор (итератор), который можно использовать для управления её выполнением. Внутри генератора используется оператор yield, который приостанавливает выполнение функции, возвращает указанное значение во внешний код и запоминает место прерывания. При последующем вызове метода next() выполнение возобновляется с места приостановки.
Пример генератора
```javascript
function* counter() {
    yield 1;
    yield 2;
    yield 3;
}

const gen = counter();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

Пример с выводом значений генератора
```javascript
function* counter() {
    yield 1;
    yield 2;
    yield 3;
}

const gen = counter();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
console.log(gen.next().value); // undefined (генератор завершил выполнение)
```

**`function*`**
function* в JS используется для объявления функции-генератора - особого типа функции, который позволяет управлять ходом выполнения, приостанавливая и возобновляя его, при этом сохраняя контекст между вызовами. Генераторы представляют мощный механизм для работы с последовательностями данных, асинхронным кодом и создания пользовательских итераторов.



## Spread operator
Spread operator `(...)` в JS позволяет расширять итерируемые объекты в места (массивы, строки, Set, объекты и тд), где ожидаются несколько элементов. Он появился в ES6 и упрощает работу с коллекциями.

**Основные применения**
1. Расширение массивов: копирование или объединение массивов без мутации оригинала
```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]
```

2. Расширение объектов: копирование или слияние объектов (только в ES9+ для объектов)
```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3 };
const merged = {...obj1, ...obj2}; // {a: 1, b: 2, c: 3}
```

3. Передача аргументов: расширение массива в функцию как отдельные аргументы
```javascript
const numbers = [13, 2, 3];
console.log('...numbers :>> ', ...numbers); // 13 2 3
console.log(Math.max(...numbers)); // 3
```
Комментарии:
- Оператор spread "раскрывает" массив и передаёт его элементы как отдельные аргументы в функцию `Math.max()`.
- Вызов `Math.max()` с развёрнутыми аргументами выглядит так: `Math.max(1, 2, 3)`.
- Без spread operator не работает, так как `Math.max([1, 2, 3]) // NaN`.

4. Клонирование: создание поверхностной копии массива или объекта
```javascript
const original = [1, 2, 3];
const copy = [...original]; // [1, 2, 3]
```

**Особенности**
Работает только с итерируемыми объектами. Для глубокого копирования нужны дополнительные инструменты. Не мутирует исходные данные.


## Rest operator
Rest operator `(...)` собирает оставшиеся элементы в массив или объект. Это обратная сторона spread operator, также введена в ES6.

**Области применения**
1. В функциях: сбор аргументов в массив:
```javascript
function sum(...args) {
  return args.reduce((a, b) => a + b, 0); 
  // 0 + 1;
  // 1 + 2; 
  // 3 + 3;
  // 6 + 4;
}

console.log(sum(1, 2, 3, 4)); // 10
```
- `(...args)` собирает все аргументы функции в массив `args`: sum(1, 2, 3, 4) -> args = [1, 2, 3 ,4]
- `reduce()` принимает функцию-колбэк к каждому элементу массива, накапливая результат. Синтаксис `array.reduce(callback, initialValue)`
- cb `(a, b) => a + b` 
- - a (аккумулятор) - промежуточный результат (сумма на текущем шаге)
- - b - текущий обрабатываемый элемент массива
- - на каждом шаге возвращает `a + b`
- `0` задаёт стартовое значение аккумулятора (без него первым элементом массива стал бы `a`, а обработка началась бы со второго элемента).


2. В деструктуризации массивов: сбор оставшихся элементов
```javascript
const [firstElement, ...rest] = [1, 2, 3];

console.log('firstElement :>> ', firstElement); // 1
console.log('rest :>> ', rest); // [2, 3]
```

- В деструктуризации объектов: сбор оставшихся свойств
```javascript
const { a, ...others } = {a: 1, b:2, c:3}

console.log('a :>> ', a); // 1
console.log('others :>> ', others); // {b: 2, c: 3}
```
Важно: название первого элемента объекта должно соответствовать ключу, иначе будет undefined

**Особенности**
Используется только в параметрах функций или левой части присваивания. Не может быть использован в середине списка; всегда используется в конце.


## Array.from()
Метод `Array.from()` создаёт ноывй массив из итерируемого объекта или массивоподобного объекта (например, NodeList, arguments, строки).

`Array.from(arrayLike[, mapFn[, thisArg]])`;

**Применение**
- Из итерируемых объектов: преобразование строки или Set в массив
```javascript
Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']
Array.from(new Set([1, 2, 3])); // [1, 2, 3]
```

- Из массивоподных объектов: преобразование arguments или NodeList
```javascript
function toArray() {
    console.log('arguments :>> ', arguments); // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    return Array.from(arguments);
}
toArray(1, 2, 3); // [1, 2, 3]
```
- `arguments` - специальный объект-подобный массив (array-like object), доступный внутри любой функции (кроме стрелочных). Он содержит все аргументы, переданные при вызове функции, в порядке их следования.


- С map-функцией: применение трансформации при создании.
Короткая запись
```javascript
Array.from([1, 2, 3], x => x * 2); // [2, 4, 6]
```

Развёрнутая запись (для лучшего понимания)
```javascript
const result = Array.from([1, 2, 3], function (x) {
    return x * 2
});

console.log(result); // [2, 4, 6]
```

- Создание массивов: генерация массивов фиксированной длины
```javascript
Array.from({ length: 5 }, (_, i) => i + 1); // [1, 2, 3, 4, 5]
```
`_` - первый параметр (значение элемента). Здест он не используется ('_' значит "неважно");
`i` - индекс элемента
`i + 1` - возвращаемое значение: к индексу `i` прибавляем `1`.

**Особенности**
Возвращает новый массив, не мутирует исходный. Поддерживает map-функцию для трансформации элементов. Полезен для работы с DOM-элементами или генерации данных.

### spread operator
Раскладывает итерируемый объект (строку, массив, Set) на отдельные элементы
Например, превращает строку в список символов, которые можно собрать в массив
```javascript
const str = 'abc';
const arr = [...str]; // ['a', 'b', 'c']
```

### rest-оператор (... в параметрах функции)
Собирает оставшиеся аргументы функции в массив
Используется только в определении функции
```javascript
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}
```

**Отличие от spread**
- Rest собирает аргументы -> в массив (... в параметрах)
- Spread раскладывает массив -> в аргументы (... при вызове)


### Array.from()
Создаёт массив либо из итерируемого объекта (строка, Set, Map, NodeList), либо из объекта со свойством length

- Первый аргумент - объект, из которого создаётся массив (обязательный)
- Второй аргумент - функция преобразования, применяемая к каждому элементу (необязательный)
- Третий аргумент - значение, используемое как this внутри mapFunction (необязательный)

```javascript
Array.from('abc'); // ['a', 'b', 'c']
Array.from(new Set([1,2,2])); // [1, 2]
Array.from({length: 2}); // [undefined, undefined]
```
**Дополнительные возможности**
Можно передать функцию преобразования:
``` javascript
Array.from('123', num => Number(num)); // [1, 2, 3]
```

### Object.keys() + map
1. `Object.keys(str)` возвращает массив индексов строки как строк: ['0', '1', '2'] для 'abc'.
```javascript
console.log(Object.keys('abc')); // ['0', '1', '2']
```

2. `map` применяет функцию к каждому индексу:
```javascript
const arr = Object.keys('abc').map(key => 'abc'[key]); // ['a', 'b', 'c']
```